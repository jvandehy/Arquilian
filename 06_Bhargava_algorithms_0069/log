This is the log for Aditya Bhargava's 2016 Book "Grokking Algorithms" (Manning)
Copyright Page
Table of Contents
Preface
Acknowledgements
About this Book
Chapter 1 Introduction to Algorithms
	Algorithm => An algorithm is a set of instructions for accomplishing a task
	Highlights
		Binary Search
		Graph Alorithm (GPS device)
		Dynamic Programming
	What you will learn about solving problems
		Examples:
		Graph Alogrithms (Video Game)	
			"you can write an AI system that follows the user around using graph algorithms"
		"k-nearest neighbors" (Recommendations)
		NP-complete problems
			"shows you how to identify those problems that come up with an algorithm that
				gives you an approximate answer"
		Know widely applicable algorithms (New Knowledge)
			algorithms for:
				AI
				databases
				bigger challenges
	Binary Search
		senerio: Facebook needs to find username
		"This is a search problem"
		solution: Binary Search
		
		Binary Search is an algorithm
			input - a sorted list of elements
			output - postion where its located
				or null
		Example: Guess a number between 1 and 100 where you are told if too high or too low.
			Technique	Result
			Guess 50 	"Too Low"	// you just eliminated half of the numbers.
			Next Guess 75	"Too High"	// again you eliminate half of the remaining numbers
			Then Guess 63	"Too High"

		Generally with binary search, you eliminate half the possibilities each step
			100=>50=>25=>13=>7=>4=>2=>1  7 steps.
		How many steps max?
			"In General, for any list of n, binary search will take log2 n steps to run the worse case.
			Example n=8;
			log 8 == 3 since 2*2*2 = 8 // (here log base 2) 
			so for a list of 8 numbers you would have to check 3 numbers at most.

			Example n = 1024   log base 2 of 1024 = 2*2*2*2*2*2*2*2*2*2  so the log is 10.
		Example using Python
			// The binary search function takes a sorted array and an item.
			// If the item is in the array, the function returns its position
			// You'll keep track of what part of the array you have searched through.

			1  low = 0
			2  high = len(list) -1

				LOW                                                 HIGH
				[ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] 
				    (These are the numbers we are searching through)

			// each time, you check the middle element:
			mid = (low + high) /2     // mid is rounded down by Python automatically if
						  // (low + high) isnt an even number
			guess = list[mid] 
			// if guess is too low, you update low accordingly
			if guess < item
			   low = mid +1
			// if guess is too high, you update high
